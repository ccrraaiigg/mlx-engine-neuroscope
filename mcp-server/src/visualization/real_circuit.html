<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Circuit: 7 + 5 = 12</title>
    <style>
        body { margin: 0; padding: 20px; background: #1a1a1a; color: white; font-family: Arial, sans-serif; }
        h1 { color: #4285f4; }
        #graph-container { width: 100%; height: 600px; border: 1px solid #333; background: #2a2a2a; margin: 20px 0; position: relative; }
        .metadata { background: #444; padding: 10px; margin: 10px 0; border-radius: 5px; font-size: 14px; }
        .node-info { background: #333; padding: 10px; margin: 10px 0; border-radius: 5px; }
        .physics-controls { position: absolute; top: 10px; right: 10px; z-index: 1000; }
        .physics-btn { 
            background: #4285f4; 
            color: white; 
            border: none; 
            padding: 8px 16px; 
            border-radius: 4px; 
            cursor: pointer; 
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .physics-btn:hover { background: #5294ff; }
        .physics-btn:active { background: #3275e5; }
        
        /* CSS Labels styles - explicit styles for visibility */
        .css-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,1);
            z-index: 1000;
            pointer-events: none;
            white-space: nowrap;
            font-family: Arial, sans-serif;
            user-select: none;
        }
        
        #labels-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <h1>Math Circuit: 7 + 5 = 12</h1>
    <div class="metadata">
        <h3>📊 Real Activation Data Summary</h3>
        <p><strong>Model:</strong> GPT-OSS-20B (20 layers, 768 hidden dimensions)</p>
        <p><strong>Nodes:</strong> 3 | <strong>Links:</strong> 2</p>
        <p><strong>Input:</strong> "What is 7 + 5?" | <strong>Output:</strong> "12"</p>
        <p><strong>Total Activations Captured:</strong> 48 tensors across layers 0 and 5</p>
    </div>
    <div id="graph-container">
        <div class="physics-controls">
            <button id="physics-btn" class="physics-btn">Play Physics</button>
        </div>
    </div>
    
    <script type="module">
        // Import Cosmos Graph and CSS Labels
        const CosmosModule = await import('./node_modules/@cosmos.gl/graph/dist/index.js');
        const LabelsModule = await import('./node_modules/@interacta/css-labels/dist/index.js');
        console.log('Cosmos module loaded:', Object.keys(CosmosModule));
        console.log('CSS Labels module loaded:', Object.keys(LabelsModule));
        const Graph = CosmosModule.Graph;
        const LabelRenderer = LabelsModule.LabelRenderer;
        console.log('Graph constructor found:', !!Graph);
        console.log('LabelRenderer found:', !!LabelRenderer);
        console.log('LabelRenderer constructor:', LabelRenderer);
        
        // Real circuit data from MLX Engine
        const rawCircuitData = {"id":"circuit_1755403390981","nodes":[{"id":"attention_head_5_2","type":"attention","layer":5,"head":2,"label":"attention_head_5_2","color":[0.4,0.6,1,1]},{"id":"mlp_8","type":"mlp","layer":8,"label":"mlp_8","color":[1,0.4,0.4,1]},{"id":"attention_head_10_1","type":"attention","layer":10,"head":1,"label":"attention_head_10_1","color":[0.4,0.6,1,1]}],"links":[{"source":"attention_head_5_2","target":"mlp_8","weight":0.78},{"source":"mlp_8","target":"attention_head_10_1","weight":0.65}],"metadata":{"title":"Math Circuit: 7 + 5 = 12","type":"circuit"}};
        
        console.log('🔥 Initializing Cosmos Graph WebGL2 visualization');
        console.log('Raw activation data keys:', Object.keys(rawCircuitData));
        console.log('Data conversion status:', rawCircuitData.nodes ? 'Already converted' : 'Raw activation data');
        console.log('Expected nodes:', rawCircuitData.nodes?.length || 'TBD');
        console.log('Expected links:', rawCircuitData.links?.length || 'TBD');
        
        async function initializeCosmosGraph() {
            try {
                // Convert browser-side processed data to Cosmos Graph format
                let graphData;
                
                // Ensure we have properly converted nodes/links data
                if (rawCircuitData.nodes && rawCircuitData.links) {
                    console.log('✅ Using converted graph data');
                    graphData = rawCircuitData;
                } else {
                    throw new Error('❌ No valid graph data found - data conversion failed. Check server-side conversion logic.');
                }
                
                console.log('Graph data for Cosmos:', graphData);
                
                // Initialize Cosmos Graph DIRECTLY with callbacks in constructor
                const container = document.getElementById('graph-container');
                const graph = new Graph(container, {
                    backgroundColor: '#1a1a1a',
                    linkWidth: 6,  // Increased from 2 to 6 for better color visibility
                    linkArrows: true, // Enable directional arrows on links
                    linkArrowsSizeScale: 1.5, // Make arrows bigger for visibility
                    pointSize: 20,
                    curvedLinks: true, // Enable curved links for visual flexibility
                    curvedLinkWeight: 0.8, // Control curve amount
                    enableSimulation: true,
                    fitViewOnInit: true, // Auto-fit view to keep nodes visible
                    fitViewPadding: 0.2, // 20% padding around nodes
                    // Exact physics settings from working localhost:8888 visualization
                    simulationFriction: 0.1,    // Low friction like working version
                    simulationGravity: 0,       // No gravity (key difference!)
                    simulationRepulsion: 0.5,   // Moderate repulsion like working version
                    // Drag and space settings from working version
                    enableDrag: true,
                    spaceSize: 4096,             // Match working version
                    scalePointsOnZoom: true,     // Match working version
                    // Event callbacks configured correctly
                    onClick: (pointIndex) => {
                        if (pointIndex !== undefined) {
                            const node = window.nodeData ? window.nodeData[pointIndex] : null;
                            console.log('Node clicked:', pointIndex, 'Label:', node?.label || 'unknown');
                        }
                    },
                    onPointMouseOver: (pointIndex) => {
                        if (pointIndex !== undefined) {
                            const node = window.nodeData ? window.nodeData[pointIndex] : null;
                            console.log('Hovering node:', pointIndex, 'Label:', node?.label || 'unknown');
                        }
                    },
                    onPointMouseOut: (pointIndex) => {
                        if (pointIndex !== undefined) {
                            console.log('Left node:', pointIndex);
                        }
                    }
                });
                
                console.log('Direct Cosmos Graph initialized with enableSimulation: true');
                
                // Store node data for callbacks
                window.nodeData = graphData.nodes;
                
                // Convert data to Cosmos Graph format 
                const positions = new Float32Array(graphData.nodes.length * 2);
                const colors = new Float32Array(graphData.nodes.length * 4);
                const links = new Float32Array(graphData.links.length * 2);
                
                console.log('Converting data for direct Cosmos Graph API...');
                
                // Debug nodes before processing
                console.log('Nodes to process:', graphData.nodes.length);
                graphData.nodes.forEach((node, index) => {
                    console.log('Node ' + index + ':', {
                        id: node.id,
                        type: node.type,
                        hasColor: !!node.color,
                        color: node.color
                    });
                });
                
                // Set positions with cluster separation for independent movement
                graphData.nodes.forEach((node, i) => {
                    let x, y;
                    
                    // Position clusters far apart to enable independent movement
                    if (node.type === 'attention' || node.type === 'attention_sub') {
                        // Attention cluster on the left
                        x = -80 + (Math.random() * 40 - 20);
                        y = Math.random() * 60 - 30;
                    } else {
                        // MLP cluster on the right  
                        x = 80 + (Math.random() * 40 - 20);
                        y = Math.random() * 60 - 30;
                    }
                    
                    positions[i * 2] = x;
                    positions[i * 2 + 1] = y;
                    
                    // Validate and set colors with fallback
                    if (node.color && Array.isArray(node.color) && node.color.length >= 4) {
                        colors[i * 4] = node.color[0];     // R
                        colors[i * 4 + 1] = node.color[1]; // G  
                        colors[i * 4 + 2] = node.color[2]; // B
                        colors[i * 4 + 3] = node.color[3]; // A
                    } else {
                        console.warn('Node ' + i + ' missing valid color, using fallback');
                        // Default to blue for missing colors
                        colors[i * 4] = 0.0;     // R
                        colors[i * 4 + 1] = 0.5; // G  
                        colors[i * 4 + 2] = 1.0; // B
                        colors[i * 4 + 3] = 1.0; // A
                    }
                    
                    const colorStr = node.color ? node.color.join(',') : 'fallback';
                    console.log('Node ' + i + ': ' + node.label + ' at (' + x + ',' + y + ') color=[' + colorStr + ']');
                });
                
                // Set links and link colors
                const linkColors = new Float32Array(graphData.links.length * 4); // RGBA for each link
                
                graphData.links.forEach((link, i) => {
                    const sourceIndex = graphData.nodes.findIndex(n => n.id === link.source);
                    const targetIndex = graphData.nodes.findIndex(n => n.id === link.target);
                    links[i * 2] = sourceIndex;
                    links[i * 2 + 1] = targetIndex;
                    
                    // Set link colors: [r, g, b, a] for each link according to API docs
                    const color = link.color || [1, 1, 1, 0.6]; // Default to white
                    linkColors[i * 4] = color[0];     // Red
                    linkColors[i * 4 + 1] = color[1]; // Green  
                    linkColors[i * 4 + 2] = color[2]; // Blue
                    linkColors[i * 4 + 3] = color[3]; // Alpha
                    
                    // Debug moved to browser console to avoid MCP protocol interference
                });
                
                // Debug the arrays before setting them
                console.log('Final arrays for Cosmos Graph:');
                console.log('positions length:', positions.length, 'expected:', graphData.nodes.length * 2);
                console.log('positions values:', Array.from(positions));
                console.log('colors length:', colors.length, 'expected:', graphData.nodes.length * 4);
                console.log('colors values:', Array.from(colors));
                console.log('links length:', links.length, 'expected:', graphData.links.length * 2);
                console.log('links values:', Array.from(links));
                console.log('point size check - should be > 0:', graph.getPointSize ? graph.getPointSize() : 'no getPointSize method');
                
                // Load data into graph using correct API
                try {
                    graph.setPointPositions(positions);
                    console.log('✅ Point positions set');
                    
                    graph.setPointColors(colors);
                    console.log('✅ Point colors set');
                    
                    graph.setLinks(links);
                    console.log('✅ Links set');
                    
                    graph.setLinkColors(linkColors);
                    console.log('✅ Link colors set');
                    
                    // Render and immediately pause to start static
                    graph.render();
                    console.log('✅ Graph rendered');
                    
                    graph.pause();
                    console.log('✅ Graph paused');
                    
                    // Fit view to see all nodes with padding
                    setTimeout(() => {
                        graph.fitView(1000, 0.2);
                        console.log('✅ Graph fitted to view');
                    }, 100);
                    
                } catch (error) {
                    console.error('❌ Error setting up graph:', error);
                    console.error('Error details:', error.message);
                    console.error('Error stack:', error.stack);
                }
                
                console.log('Direct Cosmos Graph loaded, paused, and fitted to view!');
                
                // Use already imported CSS Labels from top of script
                if (!LabelRenderer) {
                    console.error('LabelRenderer not available from @interacta/css-labels');
                    return;
                }
                
                console.log('Setting up CSS Labels with LabelRenderer:', LabelRenderer);
                
                // Create labels container
                const labelsContainer = document.createElement('div');
                labelsContainer.id = 'labels-container';
                labelsContainer.style.position = 'absolute';
                labelsContainer.style.top = '0';
                labelsContainer.style.left = '0';
                labelsContainer.style.width = '100%';
                labelsContainer.style.height = '100%';
                labelsContainer.style.pointerEvents = 'none';
                labelsContainer.style.zIndex = '1000';
                container.appendChild(labelsContainer);
                
                // Initialize CSS Labels renderer with proper options
                const labelRenderer = new LabelRenderer(labelsContainer, { 
                    pointerEvents: 'auto',
                    dontInjectStyles: false  // Let the library inject its own styles
                });
                
                // Make sure the renderer is visible
                labelRenderer.show();
                console.log('LabelRenderer initialized and shown');
                
                // Create label configurations
                console.log('Creating labels for nodes:', graphData.nodes.length);
                graphData.nodes.forEach((node, i) => {
                    console.log('Node ' + i + ':', node.id, 'Label:', node.label);
                });
                
                // Create initial labels - will be positioned after graph is fitted
                const labels = graphData.nodes.map((node, i) => {
                    return {
                        id: node.id,
                        text: node.label || node.id,
                        x: 0,  // Will be updated after fitView
                        y: 0,  // Will be updated after fitView
                        fontSize: 14,
                        color: '#ffffff',
                        opacity: 1.0,
                        shouldBeShown: true,
                        weight: 10
                    };
                });
                
                console.log('Created labels array:', labels.length);
                
                function updateLabels() {
                    const positions = graph.getPointPositions();
                    const containerRect = container.getBoundingClientRect();
                    let updatedLabels;
                    let labelElements;
                    
                    console.log('Updating labels, positions array length:', positions.length);
                    console.log('Container bounds:', { width: containerRect.width, height: containerRect.height });
                    
                    updatedLabels = labels.map((label, i) => {
                        const spaceX = positions[i * 2];
                        const spaceY = positions[i * 2 + 1];
                        const screenPos = graph.spaceToScreenPosition([spaceX, spaceY]);
                        
                        // Clamp coordinates to container bounds
                        const x = Math.max(50, Math.min(containerRect.width - 50, screenPos[0]));
                        const y = Math.max(50, Math.min(containerRect.height - 50, screenPos[1] - 35));
                        
                        console.log('Label ' + i + ' positioned near node:', { 
                            spacePos: [spaceX, spaceY], 
                            rawScreenPos: screenPos,
                            clampedPos: [x, y],
                            containerBounds: [containerRect.width, containerRect.height]
                        });
                        
                        return {
                            ...label,
                            x: x,
                            y: y,
                            shouldBeShown: true
                        };
                    });
                    
                    console.log('About to setLabels with:', updatedLabels.length, 'labels');
                    updatedLabels.forEach((label, i) => {
                        console.log('Label ' + i + ' data:', {
                            id: label.id,
                            text: label.text,
                            x: label.x,
                            y: label.y,
                            shouldBeShown: label.shouldBeShown
                        });
                    });
                    
                    labelRenderer.setLabels(updatedLabels);
                    labelRenderer.draw(true);
                    
                    // Debug: Check if DOM elements are actually created
                    labelElements = labelsContainer.querySelectorAll('div');
                    console.log('Labels updated and drawn with setLabels API');
                    console.log('DOM label elements found:', labelElements.length, 'expected:', updatedLabels.length);
                    labelElements.forEach((el, i) => {
                        console.log('Label element ' + i + ':', {
                            text: el.textContent,
                            visible: el.style.display !== 'none',
                            position: el.style.position,
                            left: el.style.left,
                            top: el.style.top,
                            className: el.className
                        });
                    });
                }
                
                // Position labels after the graph has been fitted to view
                setTimeout(() => {
                    console.log('Positioning labels after graph fitView...');
                    updateLabels();
                }, 200);
                
                // Update labels during all interactions - use setInterval for continuous updates
                setInterval(updateLabels, 100); // Update every 100ms for smooth movement
                
                // Also update on specific events
                graph.onZoom = updateLabels;
                if (graph.onSimulationTick) graph.onSimulationTick = updateLabels;
                if (graph.onDrag) graph.onDrag = updateLabels;
                if (graph.onDragEnd) graph.onDragEnd = updateLabels;
                
                // Interactions are now configured in constructor
                
                // Physics control setup - simulation disabled by config
                let physicsPlaying = false;
                const physicsBtn = document.getElementById('physics-btn');
                
                // Set correct initial button state (simulation starts paused)
                physicsBtn.textContent = 'Play Physics';
                console.log('Physics initialized as paused');
                
                // Physics toggle functionality using direct Cosmos Graph API
                physicsBtn.addEventListener('click', () => {
                    if (physicsPlaying) {
                        // Pause physics
                        graph.pause();
                        physicsBtn.textContent = 'Play Physics';
                        physicsPlaying = false;
                        console.log('Physics paused via button');
                    } else {
                        // Start physics with high energy for visible spring action
                        console.log('Starting physics...');
                        graph.start(1.0); // High energy to see spring compression/extension
                        physicsBtn.textContent = 'Pause Physics';
                        physicsPlaying = true;
                        console.log('Physics started via button with alpha=1.0');
                        
                        // No auto-refit needed anymore
                    }
                });
                
                console.log('Cosmos Graph WebGL2 visualization ready');
                
            } catch (error) {
                console.error('Cosmos Graph initialization failed:', error);
                throw error; // No fallbacks - we use Cosmos Graph or fail gracefully
            }
        }
        
        // Start the Cosmos Graph WebGL2 visualization
        initializeCosmosGraph();
        
        // Update the display in real-time
        const metadataP = document.querySelector('.metadata p:nth-child(3)');
        if (metadataP && rawCircuitData.nodes) {
            metadataP.innerHTML = '<strong>Nodes:</strong> ' + rawCircuitData.nodes.length + ' | <strong>Links:</strong> ' + (rawCircuitData.links?.length || 0);
        }
    </script>
    
    <div class="node-info">
        <h3>🧠 Circuit Structure (Real Data)</h3>
        <p><strong>Nodes:</strong> 3 components across layers</p>
        <p><strong>Links:</strong> 2 connections showing information flow</p>
        <details>
            <summary>View Raw Data</summary>
            <pre style="max-height: 300px; overflow-y: auto;">"{\n  \"nodes\": [\n    {\"id\": \"attention_head_5_2\", \"type\": \"attention\", \"layer\": 5, \"head\": 2, \"label\": \"Attention 5.2\"},\n    {\"id\": \"mlp_8\", \"type\": \"mlp\", \"layer\": 8, \"label\": \"MLP Layer 8\"},  \n    {\"id\": \"attention_head_10_1\", \"type\": \"attention\", \"layer\": 10, \"head\": 1, \"label\": \"Attention 10.1\"}\n  ],\n  \"links\": [\n    {\"source\": \"attention_head_5_2\", \"target\": \"mlp_8\", \"weight\": 0.78},\n    {\"source\": \"mlp_8\", \"target\": \"attention_head_10_1\", \"weight\": 0.65}\n  ],\n  \"metadata\": {\n    \"title\": \"Math Circuit: 7 + 5\",\n    \"type\": \"mathematical_reasoning\"\n  }\n}"</pre>
        </details>
    </div>
</body>
</html>